---
id: 9
title: "ラムダ計算——もう一つの計算の起源"
cluster: 3
clusterName: "チューリングマシンの構造"
linksTo: [2]
---

チューリングマシンが「テープと状態」で計算を定義したのに
対し、アロンゾ・チャーチのラムダ計算（λ計算、1936年）は、
「関数の適用と抽象化」のみで計算を定義する。

ラムダ計算の全体は、たった三つの構文要素からなる：
  ・変数：x
  ・関数抽象（λ抽象）：λx. M（xを引数とする関数M）
  ・関数適用：M N（関数MにNを適用する）

これだけでチューリング完全である。

恒等関数：λx. x
これは「入力をそのまま返す」関数である。

自己適用：(λx. x x)(λx. x x)
この式は自分自身に自分自身を適用し、永遠に簡約され
続ける——停止しないプログラムのラムダ計算版である。

ラムダ計算は「もの」ではなく「行為」で計算を定義する。
チューリングマシンのテープや状態のような「物理的」な
比喩はない。あるのは関数の変換だけである。

この差異は美学的にも重要である。チューリングマシンは
「空間の中で動く機械」の比喩を持つが、ラムダ計算は
「変換の連鎖」の比喩を持つ。両者はまったく異なる想像力を
喚起するにもかかわらず、計算能力としては等価である
（チャーチ＝チューリングのテーゼ）。

関数型プログラミング言語——Lisp（1958年）、Haskell（1990年）、
Clojure、Elixir——はラムダ計算の子孫である。これらの言語は
「状態の変更」を避け、「関数の合成」によってプログラムを
構築する。副作用のない純粋な関数は、数学的な関数と
同じように推論可能であり、プログラムの正しさを証明しやすい。

詩学との接続：ラムダ計算の「関数を関数に適用する」構造は、
メタファーの構造と呼応する。メタファーとは、ある概念領域
（ソース）を別の概念領域（ターゲット）に「適用」すること
であり、λf. λx. f(x) という高階関数の構造と見ることが
できないだろうか（→§2 抽象化の二つの流儀）。

さらに、ラムダ計算の【カリー＝ハワード対応】は、
プログラムと論理学の証明が同型であることを示す。
型付きラムダ計算の項は命題論理の証明に、
型は命題に対応する。「プログラムを書くこと」と
「定理を証明すること」が同じ行為であるという発見は、
計算と論理の深い統一を示している。
